require 'nn'
local Set = require 'pl.Set';
local Linear_PPS, parent = torch.class('nn.Linear_PPS', 'nn.Linear')

function Linear_PPS:backward(input, gradOutput, scale, target)
   scale = scale or 1
   self:updateGradInput(input, gradOutput)
   self:accGradParameters(input, gradOutput, scale, target)
   return self.gradInput
end

local function updateAddBuffer(self, input)
   local nframe = input:size(1)
   self.addBuffer = self.addBuffer or input.new()
   if self.addBuffer:nElement() ~= nframe then
      self.addBuffer:resize(nframe):fill(1)
   end
end

function Linear_PPS:accGradParameters(input, gradOutput, scale, target)
   scale = scale or 1
   if input:dim() == 1 then
      self.gradWeight:addr(scale, gradOutput, input)
      if self.bias then self.gradBias:add(scale, gradOutput) end
   elseif input:dim() == 2 then
      self.gradWeight:addmm(scale, gradOutput:t(), input)
      if self.bias then
         -- update the size of addBuffer if the input is not the same size as the one we had in last updateGradInput
         updateAddBuffer(self, input)
         self.gradBias:addmv(scale, gradOutput:t(), self.addBuffer)
      end
------fake sample's gradient generation------------

      local output_num = gradOutput:size(2)
      local feature_dim = input:size(2)
      local hole_set = Set(torch.totable(torch.range(1,output_num)))
      local target_set = Set(torch.totable(target))
      local comp_set = Set.difference(hole_set, target_set)
      local comp_table = {}
------Complement table
      for k,v in pairs(comp_set) do
         if v ~= nil then
         table.insert(comp_table, k)
         end
      end
------free the memory
      hole_set = nil
      target_set = nil
      comp_set = nil
------initialize the prob matrix and the weight matrix
      local prob_matrix = torch.zeros(output_num, #comp_table):cuda()
      local Weight_matrix = torch.zeros(#comp_table, feature_dim):cuda()
      local sup = 1/(output_num - 1)
------gernerate fake sample's probility to corresponding groundtruth class
      local prob = torch.Tensor(#comp_table)
      torch.uniform(prob,0.95,1)
      for i = 1,#comp_table do
         --giving other classes a unify probility by (1-prob)/(output_num - 1)
         prob_matrix:select(2,i):fill((1 - prob[i]) * sup)
         --in the gradient matrix, the ground truth class should minus 1
         prob_matrix[comp_table[i]][i] = prob[i] - 1
         --fake sample input matrix is generated by W and gaussian noise
         Weight_matrix[i] = self.gradWeight[comp_table[i]] 
-- + torch.randn(feature_dim):cuda()
      end
      self.gradWeight:addmm(prob_matrix, Weight_matrix)
   end
end
